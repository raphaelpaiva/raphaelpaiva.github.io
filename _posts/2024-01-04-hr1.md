---
layout: post
title: "D√° pra gravar √°udio da linha de comando? | O Gravador sem Cabe√ßa #1"
date: 2024-01-04
---

![](/files/hr/header-1.jpeg)

## O Problema

* Eu tenho uma banda (üç™).
* N√≥s gostamos de nos gravar üåö, √°udio e v√≠deo.
* N√≥s temos uma mesa de som velha, com uma interface USB üéöÔ∏è.
* N√≥s temos um netbook velho de um n√∫cleo, 32bits üíª.
* N√≥s queremos eventualmente gravar multipista com uma interface adicional, ou juntando v√°rias pra fazer mixagens melhores üéõÔ∏è.
* N√≥s temos celulares pra gravar v√≠deos üìπ.
* Eu tenho um [aplicativo](https://github.com/raphaelpaiva/cameracontrol) que comanda c√¢meras de celulares (android, apenas) üì±.
* N√£o sabemos se vai funcionar pois o netbook √© bem antigo e lento. Sim, j√° quero inventar antes de testar.

Pois bem. Eu tenho um raspberry pi 3 sobrando üçì.

Qual √© o problema? Nenhum, eu quero inventar alguma coisa üòÑ.

## As id√©ia

A ideia principal √©: Um gravador port√°til, **simples de usar** (pluga a(s) interface(s) e aperta gravar). E por gravar, eu entendo:
1. Gravar √°udio das interfaces
2. Enviar o comando de grava√ß√£o para as c√¢meras

## Limita√ß√µes

Se n√£o me engano, temos [ALSA](https://www.alsa-project.org/) (um sistema de √°udio do Linux) por padr√£o no [Raspberry Pi OS](https://www.raspberrypi.com/software/). D√° at√© pra agregar interfaces (pegar v√°rias e transformar em uma interface s√≥), mas tamb√©m d√° pra disparar v√°rios processos do [arecord](https://linux.die.net/man/1/arecord) (o programa gravador padr√£o do ALSA) pra gravar √°udio de interfaces diferentes ao mesmo tempo, que parece mais simples.

Bom, o raspberry pi n√£o tem tela, nem pretendo colocar. Bot√µes talvez sejam uma boa ideia, mas, pelo menos inicialmente, vou precisar de mais controle, at√© porque vou estar explorando, n√©?.

Se n√£o tem tela, n√£o tem interface gr√°fica. Daria at√© pra rodar um [Reaper](https://reaper.fm) e tentar fazer alguma m√°gica, mas acho que temos solu√ß√µes mais simples, pelo menos por enquanto. Provavelmente vou pelo caminho de interface web pra comandar por um celular ou tablet.

Pra acessar a interface web, eu vou precisar conectar no pi num ambiente potencialmente sem rede, ent√£o vou ter que sacrificar o WiFi do Pi pra criar um _hot spot_ onde o controlador vai conectar. N√£o √© muito diferente de como as mesas de som digitais funcionam.

Para as c√¢meras tem o meu projeto citado acima, mas o mais importante √© o √°udio. Mais importante ainda √©:

> Dado um Raspberry Pi 3B com uma interface de √°udio conectada, eu consigo conectar diretamente nele via WiFi com um tablet e enviar comandos pra gravar √°udio?

## Prot√≥tipo

Vamos l√°.

Tenho algumas coisas pra testar.

1. Consigo gravar de uma interface de √°udio usando arecord?
2. Consigo gravar de duas interfaces de √°udio simultaneamente usando arecord?
3. Consigo usar um servi√ßo web pra disparar a grava√ß√£o?
4. Consigo conectar e enviar os comandos acima diretamente no pi como um hot spot?

## M√£o na massa

Vamos tentar riscar o primeiro item.

Reinstalei o Pi e pluguei minha interface numa das portas USB. Vamos ver se o ALSA detectou.

Eu sei que existe um comando pra gravar √°udio direto da linha de comando, que faz parte da "caixa de ferramentas" do ALSA, chamado `arecord`.

Bora tentar:

```shellscript
raphaelpaiva@hr:~ $ arecord
Usage: arecord [OPTION]... [FILE]...

-h, --help              help
    --version           print current version
-l, --list-devices      list all soundcards and digital audio devices
-L, --list-pcms         list device names
-D, --device=NAME       select PCM by name
-q, --quiet             quiet mode
-t, --file-type TYPE    file type (voc, wav, raw or au)
-c, --channels=#        channels
-f, --format=FORMAT     sample format (case insensitive)
-r, --rate=#            sample rate
-d, --duration=#        interrupt after # seconds
-s, --samples=#         interrupt after # samples per channel
-M, --mmap              mmap stream
-N, --nonblock          nonblocking mode
-F, --period-time=#     distance between interrupts is # microseconds
-B, --buffer-time=#     buffer duration is # microseconds
    --period-size=#     distance between interrupts is # frames
    --buffer-size=#     buffer duration is # frames
-A, --avail-min=#       min available space for wakeup is # microseconds
-R, --start-delay=#     delay for automatic PCM start is # microseconds
                        (relative to buffer size if <= 0)
-T, --stop-delay=#      delay for automatic PCM stop is # microseconds from xrun
-v, --verbose           show PCM structure and setup (accumulative)
-V, --vumeter=TYPE      enable VU meter (TYPE: mono or stereo)
-I, --separate-channels one file for each channel
-i, --interactive       allow interactive operation from stdin
-m, --chmap=ch1,ch2,..  Give the channel map to override or follow
    --disable-resample  disable automatic rate resample
    --disable-channels  disable automatic channel conversions
    --disable-format    disable automatic format conversions
    --disable-softvol   disable software volume control (softvol)
    --test-position     test ring buffer position
    --test-coef=#       test coefficient for ring buffer position (default 8)
                        expression for validation is: coef * (buffer_size / 2)
    --test-nowait       do not wait for ring buffer - eats whole CPU
    --max-file-time=#   start another output file when the old file has recorded
                        for this many seconds
    --process-id-file   write the process ID here
    --use-strftime      apply the strftime facility to the output file name
    --dump-hw-params    dump hw_params of the device
    --fatal-errors      treat all errors as fatal
Recognized sample formats are: S8 U8 S16_LE S16_BE U16_LE U16_BE S24_LE S24_BE U24_LE U24_BE S32_LE S32_BE U32_LE U32_BE FLOAT_LE FLOAT_BE FLOAT64_LE FLOAT64_BE IEC958_SUBFRAME_LE IEC958_SUBFRAME_BE MU_LAW A_LAW IMA_ADPCM MPEG GSM S20_LE S20_BE U20_LE U20_BE SPECIAL S24_3LE S24_3BE U24_3LE U24_3BE S20_3LE S20_3BE U20_3LE U20_3BE S18_3LE S18_3BE U18_3LE U18_3BE G723_24 G723_24_1B G723_40 G723_40_1B DSD_U8 DSD_U16_LE DSD_U32_LE DSD_U16_BE DSD_U32_BE
Some of these may not be available on selected hardware
The available format shortcuts are:
-f cd (16 bit little endian, 44100, stereo)
-f cdr (16 bit big endian, 44100, stereo)
-f dat (16 bit little endian, 48000, stereo)
```

Ele me chamou de burro de forma educada.

`Usage: arecord [OPTION]... [FILE]...` me diz como usar esse comando. Eu tenho que passar pra ele op√ß√µes (pelo menos uma) ou arquivos (pelo menos um).

Vamos tentar passar um arquivo qualquer, deve ser o arquivo de destino da grava√ß√£o.

```
raphaelpaiva@hr:~ $ arecord opa.wav
arecord: main:830: audio open error: No such file or directory
```

Ok, erro ao abrir o √°udio. Soa at√© meio estranho. Como no Linux tudo √© representado por um arquivo, inclusive a minha interface de √°udio, eu suspeito que ele n√£o tenha conseguido abrir o dispositivo de √°udio. Talvez tenhamos que informar o `arecord` de _qual_ interface eu quero gravar. Vai que tem mais de uma.

Da sa√≠da ali em cima, onde as op√ß√µes foram listadas, algumas chamaram minha aten√ß√£o. A primeira delas foi

```
-l, --list-devices      list all soundcards and digital audio devices
```

Bora l√° tentar passar essa op√ß√£o ent√£o!

```shellscript
raphaelpaiva@hr:~ $ arecord -l
**** List of CAPTURE Hardware Devices ****
card 2: CODEC [USB Audio CODEC], device 0: USB Audio [USB Audio]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
```

Opa! Essa sa√≠da significa que ele detectou um dispositivo de sa√≠da.

Traduzindo:

* `card 2: CODEC [USB Audio CODEC], device 0: USB Audio [USB Audio]`
  - Esse dispositivo est√° na placa n√∫mero 2 (`card 2`).
  - O nome dessa placa √© `CODEC [USB Audio CODEC]`.
  - O dispositivo de sa√≠da √© o primeiro dispositivo desta placa (`device 0`).
  - O nome dele √© `USB Audio [USB Audio]`.
* `Subdevices: 1/1`
  - Ele tem um sub-dispositivo
* `Subdevice #0: subdevice #0`
  - Este sub-dispositivo √© o n√∫mero 0

Entendeu? Eu tamb√©m n√£o, mas j√° deu pra sacar que o ALSA faz refer√™ncia dos dispositivos por n√∫meros ou por nomes.

Do manual do ALSA, tem uma outra op√ß√£o interessante:

```
-L, --list-pcms
        List all PCMs defined
```

Que diabos √© um PCM? √â uma sigla pra [Pulse-code modulation](https://en.wikipedia.org/wiki/Pulse-code_modulation), ou uma das formas que um computador pode "ouvir". No contexto do ALSA, PCM √© o que vem do seu dispositivo de captura, ou seja, essa op√ß√£o lista as fontes de √°udio dispon√≠veis.

Vou escrever sobre PCM depois, √© muito interessante, mas n√£o vale alongar aqui.

```shellscript
raphaelpaiva@hr:~ $ arecord -L
null
    Discard all samples (playback) or generate zero samples (capture)
hw:CARD=CODEC,DEV=0
    USB Audio CODEC, USB Audio
    Direct hardware device without any conversions
plughw:CARD=CODEC,DEV=0
    USB Audio CODEC, USB Audio
    Hardware device with all software conversions
default:CARD=CODEC
    USB Audio CODEC, USB Audio
    Default Audio Device
sysdefault:CARD=CODEC
    USB Audio CODEC, USB Audio
    Default Audio Device
front:CARD=CODEC,DEV=0
    USB Audio CODEC, USB Audio
    Front output / input
dsnoop:CARD=CODEC,DEV=0
    USB Audio CODEC, USB Audio
    Direct sample snooping device
```

Temos um pouco mais de informa√ß√£o dessa op√ß√£o do `arecord`. Duas se√ß√µes saltam aos olhos:

```
hw:CARD=CODEC,DEV=0
    USB Audio CODEC, USB Audio
    Direct hardware device without any conversions
plughw:CARD=CODEC,DEV=0
    USB Audio CODEC, USB Audio
    Hardware device with all software conversions
```

Parece que temos acesso ao dado direto do hardware com o `hw:` e acesso ao dado tratado com o `plughw:`. Que diferen√ßa isso faz? Sei l√°. Vou chutar que podem rolar umas convers√µes de formato e taxa de amostragem, mas tem uma outra coisa mais importante:

`hw:CARD=CODEC,DEV=0` tem **muita** cara de ser um identificador de dispositivo. `CODEC` √© o nome da placa que vimos na sa√≠da do `arecord -l` e 0 √© o n√∫mero do dispositivo, ent√£o `hw:CARD=CODEC,DEV=0` deve significar a fonte de √°udio direto do hardware que vem da placa CODEC, dispositivo 0. Da mesma forma, `plughw:CARD=CODEC,DEV=0` deve significar a mesma fonte de √°udio, mas com convers√µes de software, seja l√° o que isso signifique.

A tradu√ß√£o do resto da sa√≠da do `arecord -L` fica como exerc√≠cio para o leitor üòÑ.

Uma terceira op√ß√£o que chamou aten√ß√£o foi a seguinte:
```
-D, --device=NAME       select PCM by name
```

T√° com toda cara que √© com essa op√ß√£o que eu digo qual √© a interface que eu quero utilizar. Resta saber se vamos de `hw:` ou `plughw:`. Como o `plughw:` faz convers√µes, ele parece ser a aposta mais segura.

Vamo l√°


```
raphaelpaiva@hr:~ $ arecord -Dplughw:CARD=CODEC,DEV=0 opa.wav
Recording WAVE 'opa.wav' : Unsigned 8 bit, Rate 8000 Hz, Mono
```

Parece que t√° gravando!

Como eu n√£o sabia parar, meti um ctrl+C mesmo (padr√£o para abortar programas na linha de comando) e vamos ver no que deu.

<audio controls="controls">
  <source type="audio/wav" src="/files/hr/opa.wav"></source>
  <p>Your browser does not support the audio element.</p>
</audio>

<a href="/files/hr/opa.wav" target="_blank">Se n√£o apareceu o √°udio, ouve a√≠ a alegra do nerdola</a>

Parece at√© o √°udio do Yuri Gagarin com essa qualidade tosca. Tudo bem, com 8 bits de resolu√ß√£o e uma taxa de amostragem de 8kHz n√£o d√° pra esperar muita coisa.

Vamos ver se d√° pra melhorar isso, mas eu estou curioso pra saber o que vem se eu usar o `hw:`.

```
raphaelpaiva@hr:~ $ arecord -Dhw:CARD=CODEC,DEV=0 opa.wav
Recording WAVE 'opa.wav' : Unsigned 8 bit, Rate 8000 Hz, Mono
arecord: set_params:1343: Sample format non available
Available formats:
- S8
- S16_LE
```

Opa! Eu gosto de erro assim. Que diz o que eu fiz de errado e ainda diz como consertar:

```
arecord: set_params:1343: Sample format non available
Available formats:
- S8
- S16_LE
```

Ent√£o eu tenho que especificar o formato da amostra. L√° da primeira sa√≠da do programa, d√° pra ver como e ainda tem algumas op√ß√µes interessantes pra controlar a qualidade e dura√ß√£o.

```
-c, --channels=#        channels
-f, --format=FORMAT     sample format (case insensitive)
-r, --rate=#            sample rate
-d, --duration=#        interrupt after # seconds
```

Vamos mexer s√≥ no formato por enquanto, que foi o que ele reclamou.

```
raphaelpaiva@hr:~ $ arecord -Dhw:CARD=CODEC,DEV=0 -f S16_LE opa.wav
Recording WAVE 'opa.wav' : Signed 16 bit Little Endian, Rate 8000 Hz, Mono
Warning: rate is not accurate (requested = 8000Hz, got = 11025Hz)
         please, try the plug plugin
```

Deu um warning, mas gravou. Vou chorar üò≠.
<audio controls="controls">
  <source type="audio/wav" src="/files/hr/opahw.wav"></source>
  <p>Your browser does not support the audio element.</p>
</audio>
<a href="/files/hr/opahw.wav" target="_blank">Ouve a√≠ o choro do nerdola</a>.

Reparou que a qualidade parece bem melhor? Esse foi o salto de 8bits/8000Hz pra 16bits/11025Hz. Brabo.

Vou escrever sobre o que esses n√∫mero significam, mas calma.

Vamos brincar um pouco com os outros par√¢metros.

Eu quero gravar um √°udio de 5 segundos, 16bits, 44100Hz e usando todos os 2 canais da interface. Vou plugar minha guitarra no segundo canal e bora ver se vai sair fuma√ßa.

```
arecord -Dhw:CARD=CODEC,DEV=0 -d 5 -f S16_LE -r 44100 -c 2 opa.wav
Recording WAVE 'opa.wav' : Signed 16 bit Little Endian, Rate 44100 Hz, Stereo
```

<audio controls="controls">
  <source type="audio/wav" src="/files/hr/opa2canais.wav"></source>
  <p>Your browser does not support the audio element.</p>
</audio>
<a href="/files/hr/opa2canais.wav" target="_blank">Ai papai! Emocionado. Ouve a√≠!</a>.

## Conclus√£o

D√°, hein!

Vimos como gravar √°udio de uma interface de √°udio via linha de comando usando o ALSA, sistema de som padr√£o no Raspberry Pi OS.

[Na pr√≥xima etapa]({% post_url 2024-01-05-hr2 %}) vamos ver se conseguimos gravar de duas interfaces simultaneamente.

Segue o pai!


> Dedico esse posto ao nut da minha guitarra que quebrou durante essa grava√ß√£o. N√£o coloque si no lugar da mizinha, viu?